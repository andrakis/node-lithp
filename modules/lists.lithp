% Provide functions working with lists.
(
	% Map a list with a callback.
	(def map #List,Callback :: (
		(var R (list))
		(while ((> (length List) 0)) (
			(set R (++ R (list (call Callback (head List)))))
			(set List (tail List))
		))
		% Parsing bug: must be 1 char
		R
	))

	% Foldl
	(def foldl #List,Current,Callback :: (
		(while ((> (length List) 0)) (
			(set Current (call Callback (head List) Current))
			(set List (tail List))
		))
		(get Current)
	))

	% Each. Similar to map but always returns nil.
	(def each #List,Callback :: (
		(while ((> (length List) 0)) (
			((call Callback (head List)))
			(set List (tail List))
		))
	))
	
	(def each-idx #List,Callback :: (
		(var Idx 0)
		(while ((> (length List) 0)) (
			((call Callback (head List) Idx))
			(set List (tail List))
			(set Idx (+ Idx 1))
		))
	))

	(export-global each-idx/2)

	% Sequence. Count from N0 to N1.
	(def seq #N0,N1 :: (
		(seq N0 N1 (? (< N0 N1) 1 -1))
	))
	(def seq #N0,N1,Inc :: (
		(set L (list))
		(var N (get N0))
		(while ((? (>= Inc 1) (<= N N1) (>= N N1))) (
			(set L (++ L (list N)))
			(set N (+ N Inc))
		))
		L
	))

	(export-global map/2 foldl/3 each/2 seq/2 seq/3)

	(var PermutationsPossibilities (list 0 1 2 6 24 120 720 5040 40320 362880 3628800 39916800 479001600))

	% Based on code from: http://stackoverflow.com/questions/9960908/permutations-in-javascript/37580979#37580979
	% Implements [Heap's method](http://homepage.math.uiowa.edu/~goodman/22m150.dir/2007/Permutation%20Generation%20Methods.pdf)
	(def permutations #List :: (
		(var Length (length List))
		(var Result (list-fill (index PermutationsPossibilities Length) 0))
		(var C (list-fill Length 0))
		(var I 1)
		(var J 1)
		(index-set Result 0 (slice List))
		(while ((< I Length)) (
			(if (< (index C I) I) (
				(var K (? (@ I 2) (index C I) 0))
				(var P (index List I))
				(index-set List I (index List K))
				(index-set List K P)
				(index-set C I (+ 1 (index C I)))
				(set I 1)
				(index-set Result J (slice List))
				(set J (+ 1 (get J)))
			) (else (
				(index-set C I 0)
				(set I (+ 1 (get I)))
			)))
		))
		(get Result)
	))
	(export-global permutations/1)

	(def sum #L :: ((foldl L 0 #N,A :: ((+ N A)))))
	(def prod #L :: ((foldl L 1 #N,A :: ((* A N)))))
	(export-global sum/1 prod/1)

	(def filter #List,Predicate :: (
		(var Result (list))
		(while ((> (length List) 0)) (
			(var Ele (head List))
			(if (call Predicate Ele) (
				(set Result (++ Result (list Ele)))
			))
			(set List (tail List))
		))
		(get Result)
	))

	(export-global filter/2)

	% Pass -DTEST to livium.lithp to enable.
	(if (== true (get-def 'TEST')) (
		(var SampleList (list 1 2 4 8 16 32))
		(print "Map test: " (map SampleList #N :: ((* N 2))))
		(print "Foldl test: " (foldl SampleList 0 #N,A :: ((+ N A))))
		(print "Foldl test: " (foldl SampleList 0 #N,A :: ((+ N A))))
		(print "Foldl test: " (foldl SampleList 0 #N,A :: ((+ N A))))
		(print "Empty map test: " (map (list) #N :: ((* N 2))))
		(print "Empty foldl test:" (foldl (list) 0 #N,A :: ((+ N A))))
		(each SampleList #N :: (
			(print "N:" N)
		))
		(print "Seq test:" (seq 1 5))
		(print "Reverse seq test:" (seq 5 1))
		(print "Sum test:" (sum SampleList))
		(print "Prod test:" (prod SampleList))
		(print "Permutations test: " (permutations (list 1 2 3)))
	))

)
