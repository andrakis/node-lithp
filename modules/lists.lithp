% Provide functions working with lists.
(
	% Map a list with a callback.
	(def map #List,Callback :: (
		(var R (list))
		(while ((> (length List) 0)) (
			(set R (++ R (list (call Callback (head List)))))
			(set List (tail List))
		))
		% Parsing bug: must be 1 char
		R
	))

	% Foldl
	(def foldl #List,Current,Callback :: (
		(while ((> (length List) 0)) (
			(set Current (call Callback (head List) Current))
			(set List (tail List))
		))
		(get Current)
	))

	% Each. Similar to map but always returns nil.
	(def each #List,Callback :: (
		(while ((> (length List) 0)) (
			((call Callback (head List)))
			(set List (tail List))
		))
	))

	% Sequence. Count from N0 to N1.
	(def seq #N0,N1 :: (
		(seq N0 N1 (? (< N0 N1) 1 -1))
	))
	(def seq #N0,N1,Inc :: (
		(set L (list))
		(var N (get N0))
		(while ((? (>= Inc 1) (<= N N1) (>= N N1))) (
			(set L (++ L (list N)))
			(set N (+ N Inc))
		))
		L
	))

	(export-global map/2 foldl/3 each/2 seq/2 seq/3)

	(def sum #L :: ((foldl L 0 #N,A :: ((+ N A)))))
	(def prod #L :: ((foldl L 1 #N,A :: ((* A N)))))
	(export-global sum/1 prod/1)

	% Pass -DTEST to livium.lithp to enable.
	(if (== true (get-def 'TEST')) (
		(var SampleList (list 1 2 4 8 16 32))
		(print "Map test: " (map SampleList #N :: ((* N 2))))
		(print "Foldl test: " (foldl SampleList 0 #N,A :: ((+ N A))))
		(print "Foldl test: " (foldl SampleList 0 #N,A :: ((+ N A))))
		(print "Foldl test: " (foldl SampleList 0 #N,A :: ((+ N A))))
		(print "Empty map test: " (map (list) #N :: ((* N 2))))
		(print "Empty foldl test:" (foldl (list) 0 #N,A :: ((+ N A))))
		(each SampleList #N :: (
			(print "N:" N)
		))
		(print "Seq test:" (seq 1 5))
		(print "Reverse seq test:" (seq 5 1))
		(print "Sum test:" (sum SampleList))
		(print "Prod test:" (prod SampleList))
	))

)
